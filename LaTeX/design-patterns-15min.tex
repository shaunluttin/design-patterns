% $Header$

\documentclass{beamer}

\usetheme{Darmstadt}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{textcomp}

% TypeScript Code Listings
% Taken from Lena Herrmann at 
% http://lenaherrmann.net/2010/05/20/javascript-syntax-highlighting-in-the-latex-listings-package
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{TypeScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=TypeScript,
   backgroundcolor=\color{white},
   extendedchars=true,
   basicstyle=\tiny\ttfamily,
   showstringspaces=false,
   showspaces=false,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}
% ------ End 

% https://www.sharelatex.com/learn/Inserting_Images
\usepackage{graphicx}
\graphicspath{ {images/} }

\title{Design Principles}
\subtitle{aka Object Oriented Programming}
\author{Shaun Luttin}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Goal}

    \begin{itemize}
        \item Become familiar with object-oriented design principles.
        \item Have a starting point for further research.
    \end{itemize}

\end{frame}

\begin{frame}{Why?}
    \begin{itemize}
        \item Modularity
        \item Allow change of X without changing Y.
        \item Allow reuse of X without changing Y.
    \end{itemize}
\end{frame}

\begin{frame}{The Principles}
    \begin{itemize}
        \item Encapsulate what varies.
        \item Program to interfaces not to implementations.
        \item Depend on abstractions not on concrete classes. 
        \item Only talk to your friends.
        \item A class should have only one reason to change.
        \item Don't call us, we'll call you.
        \item Classes should be open to extension and closed to modification.
        \item Favour composition over inheritance.
        \item Strive for loosely coupled designs among objects that interact.
    \end{itemize}
\end{frame}

\begin{frame}{Encapsulate what varies.}
    \begin{itemize}
        \item Encapsulate \ldots
            \begin{itemize}
                \item Restrict outside access to a thing's parts.
                \item Bundle operations with the data they use.
            \end{itemize}
        \item \ldots what varies.
            \begin{itemize}
                \item This refers to changes to source code.
                \item Source code changes due to changing requirements.
                \item E.g. A change in government may cause a change in tax law.
            \end{itemize}
        \item Restrict outside access to parts of the source code that might change due to changing requirements.
        \item ``what [do] you want to be \textit{able} to change without redesign?'' (Gamma et al, 1995)
    \end{itemize}
\end{frame}

\begin{frame}{Encapsulate what varies \ldots}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/encapsulate-what-varies.ts}
    \end{columns}
\end{frame}

\begin{frame}{Program to interfaces not to implementations.}
    \begin{itemize}
        \item An interface says what requests it will receive.
        \item An implementation says how it will handle those requests.
        \item Programming to interfaces adds polymorphism:
            \begin{itemize}
                \item it lets us change an implementation even at runtime
                \item it lets us send the same request to different classes
            \end{itemize}
        \item A separate, related SOLID principle:
            \begin{itemize}
                \item Interface Segregation Principle (Martin, 1996)
                \item Define lean interfaces that are specific to the client's needs.
                \item ``Clients should not be forced to depend upon interfaces that they do not use.'' (Martin, 1996)
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Program to interfaces \ldots}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/program-to-interfaces.ts}
    \end{columns}
\end{frame}

\begin{frame}{Depend on abstractions not on concrete classes.}
    \begin{itemize}
        \item To depend means to make a direct reference.
        \item Abstractions commit to a interface/type.
        \item Concrete classes commit to an implementation.
        \item SOLID: Dependency Inversion Principle (Martin, 1996)
        \begin{itemize}
            \item Traditionally, high-level modules depend on low-level modules:
            \item Higher \textrightarrow{} Middle \textrightarrow{} Lower \textrightarrow{} ...
            \item Dependency Inversion inverts that:
            \item Higher \textrightarrow{} Abstraction \textleftarrow{} Middle \textrightarrow{} Abstraction \textleftarrow{} Lower ...
        \end{itemize}
        \item When using dependency inversion, 
        \begin{itemize}
            \item the higher-levels define the abstractions, and
            \item the lower-levels implement the abstractions.
        \end{itemize}
        \item Why? This enables reuse of the higher-level modules.
    \end{itemize}
\end{frame}

\begin{frame}{Depend on abstractions \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/depend-on-abstractions-higher.ts}
    \end{columns}
\end{frame}

\begin{frame}{Depend on abstractions \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/depend-on-abstractions-lower.ts}
    \end{columns}
\end{frame}

\begin{frame}{Only talk to your friends.}
    \begin{itemize}
        \item The Law of Demeter (Holland, 1987)
        \item aka The Princple of Least Knowledge
        \item Why? Promotes loose coupling via encapsulation.
        \item ``Only talk to your friends''
        \item ``Only use one dot'' 
            \begin{itemize}
                \item More than one dot is cause for reflection; 
                \item it is not necessarily a violation of the LoD.
                \item E.g. fluent interfaces use many dots.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Only talk to your friends \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/only-talk-to-your-friends.ts}
    \end{columns}
\end{frame}

\begin{frame}{A class should have only one reason to change.}
    \begin{itemize}
        \item SOLID: Single Responsibility Principle (Martin, 2003)
        \item ``A class should have only one reason to change''
        \begin{itemize}
            \item Recall from ``encapsulate what varies.''
            \item This refers to changes to source code.
            \item Source code changes due to changing requirements.
        \end{itemize}
    \item Why? 
        \begin{itemize}
            \item (Re)use feature X without bringing feature A-Z.
            \item Change feature X without breaking/recompiling what depends on feature A-Z.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{A class should have only one reason to change \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/one-reason-to-change.ts}
    \end{columns}
\end{frame}

\begin{frame}{A class should have only one reason to change \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/one-reason-to-change-better.ts}
    \end{columns}
\end{frame}

\begin{frame}{Don't call us, we'll call you.}
    \begin{itemize}
        \item "Hollywood Principle" (Sweet, 1983)
        \item "Inversion of Control" (Johnson and Foote, 1988)
            \begin{itemize}
                \item Dependency injection is a type of Inversion of Control (TODO: Check this)
                \item IoC containers are a type of Dependency Injection
            \end{itemize}
        \item Dependency Inversion - who owns the abstraction?
        \item Inversion of Control - when do things happen?
        \item "coordinating and sequencing application activity"         
        \item "makes a framework different from a library":
            \begin{itemize}
                \item library: "a set of functions you can call"
                \item framework: "insert your behavior into various places"
            \end{itemize}
        \item How? subclassing, implementing interfaces, binding/events
    \end{itemize}
\end{frame}

\begin{frame}{Don't call us, we'll call you \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/inversion-of-control.ts}
    \end{columns}
\end{frame}

\begin{frame}{Don't call us, we'll call you \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/inversion-of-control-client.ts}
    \end{columns}
\end{frame}

\begin{frame}{Classes should be open to extension and closed for modification.}
    \begin{itemize}
        \item SOLID: Open-Closed Principle
        \item Once it is shipped, the source code is sacrosanct.
        \item Rather than change the source code and risk breaking it, 
        \item extend the source code via inheritance or wrapping. 
        \item E.g. the Decorator Pattern (Gamma et al, 1977)
    \end{itemize}
\end{frame}

\begin{frame}{Open-Closed Principle \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/open-closed.ts}
    \end{columns}
\end{frame}

\begin{frame}{Favour composition over inheritance.}
    \begin{itemize}
        \item Composition means a has-a relationship.
            \begin{itemize}
                \item It is often more semantically natural.
                \item It lets us swap implementations at runtime.
                \item It is good for code-reuse.
            \end{itemize}
        \item Inheritance means an is-a relationship.
            \begin{itemize}
                \item Tall class heirachies are brittle.
                \item Changing an implementation is limited to compile time.
                \item Is it good for defining taxonomies. (e.g. a String is an Object)
            \end{itemize}
        \item SOLID: Liskov Substitution (Liskov and Wing, 1994)
            \begin{itemize}
                \item A consumer that is expecting type A, 
                \item should have no surprises on receiving a child of type A.
                \item Compilers do not help: this is a semantic not syntactic.
                \item VegetableBasket should have-a List not be-a List
                \item VegetableBasket could be-a Basket not have-a Basket
            \end{itemize}
        \item https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose
    \end{itemize}
\end{frame}

\begin{frame}{Strive for loosely coupled designs among objects that interact.}
    \begin{itemize}
        \item This is the summary statement for all the princples.
        \item When loosely coupled, we can \ldots
        \item \ldots change X without needing to change Y, and
        \item \ldots use X without needing to bring along Y.
        \item Modular architecture!
    \end{itemize}
\end{frame}

\end{document}

